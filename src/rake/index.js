/*
auto-generated by: https://github.com/react-spring/gltfjsx
author: anuB_Bios Corp (https://sketchfab.com/anuB_Bios)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/cartoon-rake-low-poly-e768b8fdddfe48b8b12a5d4efbc47d53
title: cartoon rake low poly
*/

import React, { Suspense, useRef, useState, useEffect, } from 'react'
import { useLoader, useFrame } from 'react-three-fiber'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
import { useCompoundBody } from 'use-cannon'
// import { HTML } from "drei";

import glb from './out.glb'


function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}


function Model() {
  const group = useRef()
  const { nodes, materials } = useLoader(GLTFLoader, glb)
  return (
    <group ref={group} dispose={null}>
      <group position={[0, -2.2, 0]} rotation={[-Math.PI / 2, 0, -Math.PI]} scale={[0.5, 0.5, 0.5]}>
        <mesh
          material={materials.grb1}
          geometry={nodes.mesh_0.geometry}
          castShadow receiveShadow
        />
        <mesh material={materials.grb2} geometry={nodes.mesh_1.geometry} castShadow receiveShadow />
        <mesh material={materials.grb3} geometry={nodes.mesh_2.geometry} castShadow receiveShadow />
      </group>
    </group>
  )
}

const WAIT = 100

export default function RakeComponent({ position, rotation, onWhack, onWhackRest}) {

  const [hovered, setHover] = useState(false)

  const handle = [0.15, 4.35, 0.15]
  const handlePosition = [0, 0, 0]

  const teethDimensions = [1.75, 0.05, 0.42]
  const hitDimensions = [2.5, 0.5, 0.8]
  const teethPosition = [0, 2.1, -0.11]

  const [ref, api] = useCompoundBody(() => ({
    mass: 15,
    position, 
    rotation,
    shapes: [
      { type: 'Box', position: handlePosition, rotation: [0, 0, 0], args: handle },
      { type: 'Box', position: teethPosition, rotation: [0, 0, 0], args: teethDimensions },
    ],
    angularVelocity: [randomInteger(0, 3), 0, randomInteger(0, 3)]
  }))


  const rotationRef = useRef([0, 0, 0])
  useEffect(() => api.rotation.subscribe((v) => (rotationRef.current = v)), [])

  const hitClockRef = useRef(new Date().getTime())

  useEffect(() => {

    if (hovered) {

      if (hitClockRef.current + WAIT < new Date().getTime()) {
        onWhack()

        const randomX = randomInteger(-10, 10) / 50
        const randomZ = 180 //randomInteger(150, 200)

        api.applyLocalImpulse(
          [0, 0, rotationRef.current[0] < 0 ? randomZ : -randomZ],
          [randomX, -1, 0],
        )
        hitClockRef.current = new Date().getTime()
      }
    }

  }, [hovered, api, onWhack])

  const isUpright = useRef(false)

  useFrame(() => {
    if (Math.abs(rotationRef.current[0]) > 1.75) {
      isUpright.current = true
    } else {
      if (isUpright.current) {
        onWhackRest()
      }
      isUpright.current = false
    }
  })

  return (
    <group ref={ref}>
      {/* <Suspense fallback={<HTML>loading</HTML>}> */}
        <Model />
      {/* </Suspense> */}

      {/* <mesh castShadow dispose={null}>
        <boxBufferGeometry attach="geometry" args={handle} />
        <meshNormalMaterial attach="material" transparent opacity={0.3} />
      </mesh>
      <mesh castShadow position={teethPosition} dispose={null}>
        <boxBufferGeometry attach="geometry" args={teethDimensions} />
        <meshNormalMaterial attach="material" />
      </mesh> */}
      
      <mesh
        position={teethPosition}
        dispose={null}
        onPointerOver={() => setHover(true)}
        onPointerOut={() => setHover(false)}
        onPointerDown={() => setHover(true)}
        onPointerUp={() => setHover(true)}
        visible={false}
      >
        <boxBufferGeometry attach="geometry" args={hitDimensions} />
        <meshNormalMaterial attach="material" />
      </mesh>
    </group>
  )
}
